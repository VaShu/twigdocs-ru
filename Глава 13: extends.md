
Тег ```extends``` предназначен для расширения одного шаблона другим. Как и в PHP, Twig не поддерживает множественное наследование, поэтому в каждом шаблоне может быть лишь один вызов ```extends``` тега. Однако Twig поддерживает горизонтальное переиспользование шаблонов.

Давайте определим базовый шаблон, ```base.html```, который будет представлять структуру нашего HTML-документа:

```twig
<!DOCTYPE html>
<html>
  <head>
    {% block head %}
      <link rel="stylesheet" href="style.css" />
      <title>{% block title %}{% endblock %} - My Webpage</title>
    {% endblock %}
 </head>
 <body>
    <div id="content">
      {% block content %}{% endblock %}
    </div>
    
    <div id="footer">
      {% block footer %}
        &copy; Copyright 2011 by <a href="http://domain.invalid/">you</a>.
      {% endblock %}
    </div>
 </body>
</html>
```

В данном примере содержатся 4 блока, которые могут быть перезаписаны дочерними шаблонами.

Всё, что из себя представляет тег ```block```, так это команду, которая указывает шаблонизатору, что определенные части страницы могут быть перезаписаны дочерними шаблонами.

###### Дочерний шаблон

Дочерний шаблон может выглядеть следующим образом:

```twig
{% extends 'base.html' %}

{% block title %}Index{% endblock %}
{% block head %}
  {{ parent() }}
  <style type="text/css">
    .important { color: #336699; }
  </style>
{% endblock %}
{% block content %}
  <h1>Index</h1>
  <p class="important">
    Добро пожаловать на моё крутую страничку!
  </p>
{% endblock %}
```

Тег ```extends``` является здесь ключевым и сообщает шаблонизатору, что данный шаблон расширяет имеющийся ```base.html``` шаблон. В процессе обработки шаблона первым делом происходит поиск родительского шаблона, поэтому тег ```extends``` должен стоять всегда в самом начале и быть первым используемым тегом.

Обратите внимание, что наш дочерний шаблон не перезаписывает и не определяет блок ```footer```, поэтому по-умолчанию используется вариант из родительского шаблона. 

Возможности определить несколько тегов с одинаковым названием в рамках одного шаблона нет, иначе это вызвало бы проблемы с определением того, какой именно дочерний блок должен быть заполнен.

Если есть необходимость вывести содержимое блока несколько раз, то для этого можно воспользоваться функцией ```block()```:

```twig
<title>{% block title %}{% endblock %}</title>
<h1>{% block('title') %}</h1>
{% block body %}{% endblock %}
```

###### Родительские блоки

Безусловно есть возможность вывести в дочернем блоке содержимое родительского блока, для этого необходимо воспользоваться функцией ```parent()```:

```twig
{% block sidebar %}
  <h3>Table of contents</h3>
  ...
  {{ parent() }}
{% endblock %}
```

###### Именованые закрывающие теги

Для лучшей читабельности кода Twig даёт возможность вместе с закрывающим тегом ```endblock``` указать и имя самого закрываемого блока:

```twig
{% block sidebar %}
  {% block content %}
    ...
  {% endblock content %}
{% endblock sidebar %}
```

###### Вложенность блоков и область видимости

Блоки могут быть использованы и для определения вложенных структур (в несколько уровней). По-умолчанию у блоков есть доступ к внешним переменным (переменным, находящимся во внешней области видимости):

```twig
{% for item in seq %}
  <li>{% block loop_item %}{{ item }}{% endblock %}</li>
{% endfor %}
```

###### Сокращения

Для блоков с небольшим количеством содержимого возможно использование сокращенных форм вызовов, например, в приведённом примере оба вызова идентичны:

```twig
{% block title %}
  {{ page_title|title }}
{% endblock %}
```

```twig
{% block title page_title|title %}
```

###### Динамическое наследование

Twig поддерживает динамическое наследование через передачу произвольной строки для тега ```extends```:

```twig
{% extends some_var %}
```

Если переменная определяется как экземпляр класса ```Twig_Template``` или ```Twig_TemplateWrapper```, то переданный шаблон будет использован в качестве основного (родительского):

```php
// {% extends layout %}

$layout = $twig->load("some_layout_template.twig");
$twig->display($layout, array('layout' => $layout));
```

Тегу ```extends``` так же может быть передан список шаблонов, которые он проверит в порядке перечисления на существование и воспользуется первым, который найдёт:

```twig
{% extends ['layout1.twig', 'layout2.twig'] %}
```

###### Условное наследование

Так как в качестве имени родительского шаблона может выступать любой выражение результат которого строковое название родительского шаблона, то при использовании ```extends``` тега возможно использование условных выражений:

```twig
{% extends standalone ? "minimum.twig" : "premium.twig" %}
```

В приведенном примере шаблон будет расширять ```minimum.twig```, если переменная ```standalone``` примет значение ```true``` и ```premium.twig```, если переменная ```standalone``` примет значение ```false```.

###### Как работают блоки?

Блок даёт возможность изменить то, каким образом отображается определенная часть шаблона, но блоки никоим образом не влияют и не вмешиваются в саму логику отображения. Давайте возьмем в качестве примера этот небольшой отрывок кода и посмотрим, как блоки работают и, что еще важнее, как они не работают и чего не делают:

```twig
{# base.twig #}

{% for post in posts %}
  {% block post %}
    <h1>{{ post.title }}</h1>
    <p>{{ post.body }}</p>
  {% endblock %}
{% endfor %}
```

Если вы попробуете отобразить результат отображения шаблона, то они будут одинаковы - как с использованием блока, так и без использования блока. Блок внутри цикла всего лишь способ предоставить возможность дочерним шаблона перезаписывать его содержимое.

```twig
{# child.twig #}

{% extends "base.twig" %}

{% block post %}
  <article>
    <header>{{ post.header }}</header>
    <section>{{ post.text }}</section>
  </article>
{% endblock %}
```

Теперь, при выполнении цикла, тело цикла будет использовать дочерний блок из ```child.twig``` вместо того, который был определён в родительском шаблоне; выполнемый цикл будет аналогичен следующему:

```twig
{% for post in posts %}
  <article>
    <header>{{ post.header }}</header>
    <section>{{ post.text }}</section>
  </article>
{% endfor %}
```

Давайте рассмотрим другой пример: блок заключенный в ```if```-тег.

```twig
{% if posts is empty %}
  {% block head %}
    {{ parent() }}
    
    <meta name="robots" content="noindex, follow">
  {% endblock head %}
{% endif %}
```

В противоположность тому, что вы подумали - этот шаблон не определяет условный блок; он позволяет дочернему шаблону перезаписать то, что может быть отображено в том случае, если выражение ```posts is empty``` будет определено как ```true```.

Если необходимо, чтобы результат отображения был условным, то воспользуйтесь таким подходом:

```twig
{% block head %}
    {{ parent() }}
    
    {% if posts is empty %}
      <meta name="robots" content="noindex, follow">
    {% endif %}
{% endblock head %}
```
