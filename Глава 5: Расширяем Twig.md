
Twig может быть расширен различными способами - добавлением новых тегов, фильтров, тестов, операторов, глобальных переменных и функций. Присутствует возможность расширить сам парсер.

Первая часть этой главы расскажет о том, как просто и быстро можно расширить возможности Twig. Если у вас возникнет желание поделиться своим расширением с сообществом, то о том, как это сделать вы узнаете в конце этой секции. 

Перед тем как приступить к расширению возможностей Twig необходимо понять разницу между имеющимися ключевыми подходами к разработке расширения и ситуациях, в которых их необходимо использовать.

Во-первых, стоит иметь ввиду, что в Twig присутствуют две ключевые языковые структуры:

- ```{% %}```: используется для выполнения команд
- ```{{ }}```: используется для вывода значения выражения

Чтобы лучше понять причины по которым Twig использует такое кол-во точек входа, разберём пример с генератором ```Lorem ispum```, который на входе должен получать кол-во слов необходимое для генерирования:

Мы можем создать ```lipsum```-тег:

```twig
{% lipsum 40 %}
```

Это будет работать, однако использование тега для таких целей не является хорошим решением, по трём причинам:

- ```lipsum``` не является языковой конструкцией
- тег что-то выводит
- тег недостаточно гибок и не может быть использован в выражениях

```twig
{{ 'some text' ~ {% lipsum 40 %} ~ ' some more text' }}
```

В действительно, редки случаи, когда вам необходимо будет создавать теги; и это хорошие новости потому, что создание расширений тегов является самой сложной темой.

Попробуем использовать ```lipsum``` в качестве фильтра:

```twig
{{ 40|lipsum }}
```

Это будет работать, но выглядит странно. Фильтр предназначен для преобразования значений, вместо этого мы используем значение 40 для генерирации строки и вывода результата (40 - это аргумент для фильтра, а не значение, которые мы хотим преобразовать).

Дальше, попробуем ```lipsum``` в качестве функции:

```twig
{{ lipsum(40) }}
```

Вот мы и нашли то, что искали! Для данного конкретного примера, расширение Twig функцией является оптимальным вариантом. Генерируемое значение может быть использовано в выражениях:

```twig
{{ 'some text' ~ lipsum(40) ~ 'some more text' }}

{{ set text = lipsum(40) }}
```

Последнее, но не менее важное замечание: мы можем использовать глобальный объект с методом для генерирования нужного нам текста:

```twig
{{ text.lipsum(40) }}
```

Хорошим тоном считается использование функций для решения частых задач, а глобальные объекты для всего остального.

Держите в голове следующее, если вдруг решитесь расширять Twig:

Что | Сложность реализации | Как часто | Когда
----|-----|----|----
macro|тривиально|часто|генерирование содержимого
global|тривиально|часто|вспомогательные объекты
function|тривиально|часто|генерирование содержимого
filter|тривиально|часто|преобразование значений
tag|сложно|редко|языковые структуры (DSL)
test|тривиально|редко|логические проверки
operator|тривиально|редко|преобразование значений

###### Глобальные переменные

Глобальная переменна аналогично обычной переменной, лишь с одним различием - она доступна во всех шаблонах и макросах.

```php
$twig = new Twig_Environment($loader);
$twig->addGlobal('text', new Text());
```

После этого переменная ```text``` станет доступна во всех шаблонах:

```twig
{{ text.lipsum(40) }}
```

###### Фильтры

Создавать фильтры настолько же просто, насколько просто связать имя переменно с вызываемой функцией:

```php
// анонимная функция
$filter = new Twig_Filter('rot13', function ($string){
  return str_rot13($string);
});

// или просто PHP-функция
$filter = new Twig_Filter('rot13', 'str_rot13');

// или статичный метод класса
$filter = new Twig_Filter('rot13', ['SomeClass', 'rot13Filter']);
$filter = new TwigFilter('rot13', 'SomeClass::rot13Filter');

// или метод экземпляра
$filter = new Twig_Filter('rot13', [$this, 'rot13Filter']);
// данный метод требует реализации во время исполнения
$filter = new Twig_Filter('rot13', ['SomeClass', 'rot13Filter'])
```

Первый передаваемый параметр в ```Twig_Filter``` - название фильтра, которое будет использоваться в шаблонах; второй параметр - что именно будет вызываться.

После объявления фильтра - добавьте его в среду окружения:

```php
$twig = new Twig_Environment($loader);
$twig->addFilter($filter);
```

А вот как воспользоваться фильтром в шаблоне:

```twig
{{ 'Twig'|rot13 }}
```

Когда происходит вызов из Twig, PHP-вызываемая функция или метод получают в качестве первого аргумента вычисленное значение до ```|```, а в качестве дополнительных - перечисленные в ```()```.

Например:

```twig
{{ 'TWIG'|lower }}
{{ now|date('Y/m/d') }}
```

... будет скомпилировано в нечто подобное:

```twig
<? echo strtolower('TWIG') ?>
<? echo twig_date_format($now, 'Y/m/d') ?>
```

Последний аргумент при создании экземпляра класса ```Twig_Filter``` - массив опций:

```php
$filter = new Twig_Filter('rot13', 'str_rot13', $options);
```

###### Фильтры окружения

Если в создаваемом фильтре необходимо получить доступ к переменной окружения, установите опцию ```needs_environment``` в ```true```, Twig передаст текущее окружения в качестве первого аргумента при вызове фильтра:

```php
$filter = new Twig_Filter('rot13', function (Twig_Environment $env, $string) {
  // например, получим текущую кодировку
  $charset = $env->getCharset();
  
  return str_rot13($string);
}, ['needs_environment' => true]);
```

###### Фильтры контекста

Если есть необходимость в фильтре получить доступ к текущему контексту, то необходимо установить опцию ```needs_context``` в значение ```true```:

```php
$filter = new Twig_Filter('ro13', function($context, $string) {
  // ...
}, array('needs_context' => true));

$filter = new Twig_Filter('rot13', function(Twig_Environment $env, $context, $string) {
  // ...
}, array('needs_context' => true, 'needs_environment' => true));
```

###### Автоматическое экранирование

Если автоматическое экранирование включено, то перед выводом данные будут экранированы. Если же ваш фильтр работает в качестве экранировщика (или явно выводит HTML или JS код), то вы определенно захотите выводить исходный код без последующего экранирования. Для такого случае есть опция ```is_safe```:

```php
$filter = new Twig_Filter('nl2br', 'nl2br', array('is_safe' => array('html')));
```

Некоторые фильтры, возможно, будут работать сразу с данными, которые уже экранированы, например, при добавлении безопасных HTML-тегов в исходный небезопасный вывод. В таком случае воспользуйтесь опцией ```pre_escape``` для того, чтобы переданные данные в ваш фильтр были уже экранированными:

```php
$filter = new Twig_Filter('somefilter', 'somefilter', array('pre_escape' => 'html', 'is_safe' => array('html')));
```

###### Фильтры с переменным количество аргументов

Если необходимо, чтобы фильтр принимал переменное количество аргументов, необходимо установить опцию ```is_variadic``` в ```true```:

```php
$filter = new Twig_Filter('thumbnail', function($file, array $options = array()){
  // ...
}, array('is_variadic' => true));
```

Обратите внимание, что именные аргументы, передаваемые в фильтр не могут быть проверены на доступность, поэтому автоматически окажутся в массиве опций ```$options```.

###### Динамические фильтры

Фильтр, в названии которого содержится символ ```*```, является динамическим фильтром. Вместо символа ```*``` может быть любое строковое значение:

```php
$filter = new Twig_Filter('*_path', function($name, $arguments) {
  // ...
});
```

Следующие фильтры пройдут успешную проверку по имени:

- product_path
- category_path

Динамический фильтр может содержать более одной динамической части:

```php
$filter = new Twig_Filter('*_path_*', function($name, $suffix, $arguments){
  // ...
});
```

Значения всех динамических частей названия фильтра будут переданы до любых аргументов самого фильтра, но после аргументов окружения и контекста. Для примера, вызов следующего фильтра ```'foo'|a_path_b()``` сформирует следующий порядок аргументов в фильтр - ```('a', 'b', 'foo')```.

###### Устаревшие фильтры

Вы можете отметить фильтр как устаревший воспользовавшись опцией ```depricated``` в значении ```true```. Если есть альтернативный фильтр, который должен быть использован в качестве замены, то его можно указать через опцию ```alternative```:

```php
$filter = new Twig_Filter('obsolete', function () {
}, array('deprecated' => true, 'alternative' => 'new_one'));
```

Если используется устаревший фильтр, то Twig на этапе компиляции шаблона, использующего указанный фильтр, генерирует предупреждение.

###### Функции

Расширение Twig функциями происходит по такому же принципу, что и расширение фильтрами с единственной разницей - создаётся экземпляр класса ```Twig_Function```:

```php
$twig = new Twig_Environment($loader);
$func = new Twig_Function('function_name', function () {
  // ...
});

$twig->addFunction($func);
```

Функции поддерживают все те же опции, которые поддерживаются фильтрами, кроме ```pre_escape``` и ```preserves_safety```.

###### Логические тесты

Тесты определяются таким же образом, как функции и фильтры с одной единственной разницей - создаётся экземпляр класса ```Twig_Test```:

```php
$twig = new Twig_Environment($loader);
$test = new Twig_Test('test_name', function () {
  // ...
});

$twig->addTest($test);
```

Тесты позволяют создавать настраиваемую логику обработки логических выражений. В качестве простого примера рассмотрим создание логического теста, который будет проверять, является ли объект красным:

```php
$twig = new Twig_Environment($loader);
$test = new Twig_Test('red', function ($value) {
  if (isset($value->color) && $value->color == 'red') {
    return true;
  }
  if (isset($value->paint) && $value->paint == 'red') {
    return true;
  }
  
  return false;
});

$twig->addTest($test);
```

Тесты всегда должны возвращать только ```true``` / ```false``` значения.

При создании тестов вы так же можете воспользоваться классом ```test_node``` для настраиваемой компиляции. Это крайне полезная возможность, если тест может быть скомпилирован с использованием примитивных типов PHP. Такой подход используется во многих тестах самого Twig:

```php
$twig = new Twig_Environment($loader);
$test = new Twig_Test(
  'odd',
  null,
  array('node_class' => 'Twig_Node_Expression_Test_Odd'));
  
class Twig_Node_Expression_Test_Odd extends Twig_Node_Expression_Test
{
  public function compile(Twig_Compiler $compiler)
  {
    $compiler
      ->raw('(')
      ->subcompile($this->getNode('node'))
      ->raw(' % 2 == 1')
      ->raw(')')
  }
}
```

Приведенный выше пример показывает, как можно создавать тесты используя встроенный класс для представления узлов. Как видно из примера, узел имеет доступ к под-узлу, который содержит тестируемое значение. Например, при использовании теста ```odd```:

```twig
{% if my_value is odd %}
```

... под-узел ```node``` будет содержать выражение ```my_value```. Тесты основанные на узлах так же получают доступ к узлу ```arguments```. Этот узел будет содержать различные вспомогательные аргументы, которые были переданы вашему тесту.

Если вам необходимо передать произвольное количество переменных или именных аргументов, то установите опцию ```is_variadic``` в ```true```. Тесты, как функции и фильтры, поддерживают динамические имена.

##### Теги

Одна из великолепных возможностей таких шаблонизаторов как Twig это возможность создания собственных языковых структур. Это так же одна из самых сложных для реализации возможностей, потому что требует знаний о том, как работает Twig внутри.

Давайте попробуем создать простой тег ```set```, который позволит объявить переменную в шаблоне и присвоить ей значение. Тег может быть использован следующим образом:

```twig
{% set name = 'Andrew' %}
{{ name }}
```

Тег ```set``` доступен в части расширения ядра Twig, поэтому всегда доступен. Встроенная версия значительно эффективнее и представляет большую гибкость в использовании (например, массовое присвоение). 

Три шага являются обязательными при создании нового тега:

- Описать класс парсера (```token parser```)
- Описать класс узла (```node class```)
- Зарегистрировать тег.
