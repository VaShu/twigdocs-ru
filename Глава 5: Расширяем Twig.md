
Twig может быть расширен различными способами - добавлением новых тегов, фильтров, тестов, операторов, глобальных переменных и функций. Присутствует возможность расширить сам парсер.

Первая часть этой главы расскажет о том, как просто и быстро можно расширить возможности Twig. Если у вас возникнет желание поделиться своим расширением с сообществом, то о том, как это сделать вы узнаете в конце этой секции. 

Перед тем как приступить к расширению возможностей Twig необходимо понять разницу между имеющимися ключевыми подходами к разработке расширения и ситуациях, в которых их необходимо использовать.

Во-первых, стоит иметь ввиду, что в Twig присутствуют две ключевые языковые структуры:

- ```{% %}```: используется для выполнения команд
- ```{{ }}```: используется для вывода значения выражения

Чтобы лучше понять причины по которым Twig использует такое кол-во точек входа, разберём пример с генератором ```Lorem ispum```, который на входе должен получать кол-во слов необходимое для генерирования:

Мы можем создать ```lipsum```-тег:

```twig
{% lipsum 40 %}
```

Это будет работать, однако использование тега для таких целей не является хорошим решением, по трём причинам:

- ```lipsum``` не является языковой конструкцией
- тег что-то выводит
- тег недостаточно гибок и не может быть использован в выражениях

```twig
{{ 'some text' ~ {% lipsum 40 %} ~ ' some more text' }}
```

В действительно, редки случаи, когда вам необходимо будет создавать теги; и это хорошие новости потому, что создание расширений тегов является самой сложной темой.

Попробуем использовать ```lipsum``` в качестве фильтра:

```twig
{{ 40|lipsum }}
```

Это будет работать, но выглядит странно. Фильтр предназначен для преобразования значений, вместо этого мы используем значение 40 для генерирации строки и вывода результата (40 - это аргумент для фильтра, а не значение, которые мы хотим преобразовать).

Дальше, попробуем ```lipsum``` в качестве функции:

```twig
{{ lipsum(40) }}
```

Вот мы и нашли то, что искали! Для данного конкретного примера, расширение Twig функцией является оптимальным вариантом. Генерируемое значение может быть использовано в выражениях:

```twig
{{ 'some text' ~ lipsum(40) ~ 'some more text' }}

{{ set text = lipsum(40) }}
```

Последнее, но не менее важное замечание: мы можем использовать глобальный объект с методом для генерирования нужного нам текста:

```twig
{{ text.lipsum(40) }}
```

Хорошим тоном считается использование функций для решения частых задач, а глобальные объекты для всего остального.

Держите в голове следующее, если вдруг решитесь расширять Twig:

Что | Сложность реализации | Как часто | Когда
----|-----|----|----
macro|тривиально|часто|генерирование содержимого
global|тривиально|часто|вспомогательные объекты
function|тривиально|часто|генерирование содержимого
filter|тривиально|часто|преобразование значений
tag|сложно|редко|языковые структуры (DSL)
test|тривиально|редко|логические проверки
operator|тривиально|редко|преобразование значений

###### Глобальные переменные

Глобальная переменна аналогично обычной переменной, лишь с одним различием - она доступна во всех шаблонах и макросах.

```php
$twig = new Twig_Environment($loader);
$twig->addGlobal('text', new Text());
```

После этого переменная ```text``` станет доступна во всех шаблонах:

```twig
{{ text.lipsum(40) }}
```

###### Фильтры

Создавать фильтры настолько же просто, насколько просто связать имя переменно с вызываемой функцией:

```php
// анонимная функция
$filter = new Twig_Filter('rot13', function ($string){
  return str_rot13($string);
});

// или просто PHP-функция
$filter = new Twig_Filter('rot13', 'str_rot13');

// или статичный метод класса
$filter = new Twig_Filter('rot13', ['SomeClass', 'rot13Filter']);
$filter = new TwigFilter('rot13', 'SomeClass::rot13Filter');

// или метод экземпляра
$filter = new Twig_Filter('rot13', [$this, 'rot13Filter']);
// данный метод требует реализации во время исполнения
$filter = new Twig_Filter('rot13', ['SomeClass', 'rot13Filter'])
```

Первый передаваемый параметр в ```Twig_Filter``` - название фильтра, которое будет использоваться в шаблонах; второй параметр - что именно будет вызываться.

После объявления фильтра - добавьте его в среду окружения:

```php
$twig = new Twig_Environment($loader);
$twig->addFilter($filter);
```

А вот как воспользоваться фильтром в шаблоне:

```twig
{{ 'Twig'|rot13 }}
```

Когда происходит вызов из Twig, PHP-вызываемая функция или метод получают в качестве первого аргумента вычисленное значение до ```|```, а в качестве дополнительных - перечисленные в ```()```.

Например:

```twig
{{ 'TWIG'|lower }}
{{ now|date('Y/m/d') }}
```

... будет скомпилировано в нечто подобное:

```twig
<? echo strtolower('TWIG') ?>
<? echo twig_date_format($now, 'Y/m/d') ?>
```

Последний аргумент при создании экземпляра класса ```Twig_Filter``` - массив опций:

```php
$filter = new Twig_Filter('rot13', 'str_rot13', $options);
```

###### Фильтры окружения

Если в создаваемом фильтре необходимо получить доступ к переменной окружения, установите опцию ```needs_environment``` в ```true```, Twig передаст текущее окружения в качестве первого аргумента при вызове фильтра:

```php
$filter = new Twig_Filter('rot13', function (Twig_Environment $env, $string) {
  // например, получим текущую кодировку
  $charset = $env->getCharset();
  
  return str_rot13($string);
}, ['needs_environment' => true]);
```

###### Фильтры контекста

Если есть необходимость в фильтре получить доступ к текущему контексту, то необходимо установить опцию ```needs_context``` в значение ```true```:

```php
$filter = new Twig_Filter('ro13', function($context, $string) {
  // ...
}, array('needs_context' => true));

$filter = new Twig_Filter('rot13', function(Twig_Environment $env, $context, $string) {
  // ...
}, array('needs_context' => true, 'needs_environment' => true));
```

###### Автоматическое экранирование

Если автоматическое экранирование включено, то перед выводом данные будут экранированы. Если же ваш фильтр работает в качестве экранировщика (или явно выводит HTML или JS код), то вы определенно захотите выводить исходный код без последующего экранирования. Для такого случае есть опция ```is_safe```:

```php
$filter = new Twig_Filter('nl2br', 'nl2br', array('is_safe' => array('html')));
```

Некоторые фильтры, возможно, будут работать сразу с данными, которые уже экранированы, например, при добавлении безопасных HTML-тегов в исходный небезопасный вывод. В таком случае воспользуйтесь опцией ```pre_escape``` для того, чтобы переданные данные в ваш фильтр были уже экранированными:

```php
$filter = new Twig_Filter('somefilter', 'somefilter', array('pre_escape' => 'html', 'is_safe' => array('html')));
```

###### Фильтры с переменным количество аргументов

Если необходимо, чтобы фильтр принимал переменное количество аргументов, необходимо установить опцию ```is_variadic``` в ```true```:

```php
$filter = new Twig_Filter('thumbnail', function($file, array $options = array()){
  // ...
}, array('is_variadic' => true));
```

Обратите внимание, что именные аргументы, передаваемые в фильтр не могут быть проверены на доступность, поэтому автоматически окажутся в массиве опций ```$options```.

###### Динамические фильтры

Фильтр, в названии которого содержится символ ```*```, является динамическим фильтром. Вместо символа ```*``` может быть любое строковое значение:

```php
$filter = new Twig_Filter('*_path', function($name, $arguments) {
  // ...
});
```

Следующие фильтры пройдут успешную проверку по имени:

- product_path
- category_path

Динамический фильтр может содержать более одной динамической части:

```php
$filter = new Twig_Filter('*_path_*', function($name, $suffix, $arguments){
  // ...
});
```

Значения всех динамических частей названия фильтра будут переданы до любых аргументов самого фильтра, но после аргументов окружения и контекста. Для примера, вызов следующего фильтра ```'foo'|a_path_b()``` сформирует следующий порядок аргументов в фильтр - ```('a', 'b', 'foo')```.

###### Устаревшие фильтры

Вы можете отметить фильтр как устаревший воспользовавшись опцией ```depricated``` в значении ```true```. Если есть альтернативный фильтр, который должен быть использован в качестве замены, то его можно указать через опцию ```alternative```:

```php
$filter = new Twig_Filter('obsolete', function () {
}, array('deprecated' => true, 'alternative' => 'new_one'));
```

Если используется устаревший фильтр, то Twig на этапе компиляции шаблона, использующего указанный фильтр, генерирует предупреждение.

###### Функции

Расширение Twig функциями происходит по такому же принципу, что и расширение фильтрами с единственной разницей - создаётся экземпляр класса ```Twig_Function```:

```php
$twig = new Twig_Environment($loader);
$func = new Twig_Function('function_name', function () {
  // ...
});

$twig->addFunction($func);
```

Функции поддерживают все те же опции, которые поддерживаются фильтрами, кроме ```pre_escape``` и ```preserves_safety```.

###### Логические тесты

Тесты определяются таким же образом, как функции и фильтры с одной единственной разницей - создаётся экземпляр класса ```Twig_Test```:

```php
$twig = new Twig_Environment($loader);
$test = new Twig_Test('test_name', function () {
  // ...
});

$twig->addTest($test);
```

Тесты позволяют создавать настраиваемую логику обработки логических выражений. В качестве простого примера рассмотрим создание логического теста, который будет проверять, является ли объект красным:

```php
$twig = new Twig_Environment($loader);
$test = new Twig_Test('red', function ($value) {
  if (isset($value->color) && $value->color == 'red') {
    return true;
  }
  if (isset($value->paint) && $value->paint == 'red') {
    return true;
  }
  
  return false;
});

$twig->addTest($test);
```

Тесты всегда должны возвращать только ```true``` / ```false``` значения.

При создании тестов вы так же можете воспользоваться классом ```test_node``` для настраиваемой компиляции. Это крайне полезная возможность, если тест может быть скомпилирован с использованием примитивных типов PHP. Такой подход используется во многих тестах самого Twig:

```php
$twig = new Twig_Environment($loader);
$test = new Twig_Test(
  'odd',
  null,
  array('node_class' => 'Twig_Node_Expression_Test_Odd'));
  
class Twig_Node_Expression_Test_Odd extends Twig_Node_Expression_Test
{
  public function compile(Twig_Compiler $compiler)
  {
    $compiler
      ->raw('(')
      ->subcompile($this->getNode('node'))
      ->raw(' % 2 == 1')
      ->raw(')')
  }
}
```

Приведенный выше пример показывает, как можно создавать тесты используя встроенный класс для представления узлов. Как видно из примера, узел имеет доступ к под-узлу, который содержит тестируемое значение. Например, при использовании теста ```odd```:

```twig
{% if my_value is odd %}
```

... под-узел ```node``` будет содержать выражение ```my_value```. Тесты основанные на узлах так же получают доступ к узлу ```arguments```. Этот узел будет содержать различные вспомогательные аргументы, которые были переданы вашему тесту.

Если вам необходимо передать произвольное количество переменных или именных аргументов, то установите опцию ```is_variadic``` в ```true```. Тесты, как функции и фильтры, поддерживают динамические имена.

##### Теги

Одна из великолепных возможностей таких шаблонизаторов как Twig это возможность создания собственных языковых структур. Это так же одна из самых сложных для реализации возможностей, потому что требует знаний о том, как работает Twig внутри.

Давайте попробуем создать простой тег ```set```, который позволит объявить переменную в шаблоне и присвоить ей значение. Тег может быть использован следующим образом:

```twig
{% set name = 'Andrew' %}
{{ name }}
```

Тег ```set``` доступен в ```Core```-части расширения ядра Twig, поэтому всегда доступен. Встроенная версия значительно эффективнее и представляет большую гибкость в использовании (например, массовое присвоение). 

Три шага являются обязательными при создании нового тега:

- Описать класс парсера (```token parser```)
- Описать класс узла (```node class```)
- Зарегистрировать тег.

###### Регистрация нового тега

Добавить новый тег так же просто, как вызвать метод ```addTokenParser``` экземпляра класса ```Twig_Environment```:

```php
$twig = new Twig_Environment($loader);
$twig->addTokenParser(new Project_Set_TokenParser());
```

###### Определение парсера токенов

Теперь двайте взглянем на код ```Project_Set_TokenParser```:

```php
class Project_Set_TokenParser extends Twig_TokenParser
{
  public function parse(Twig_Token $token)
  {
    $parser = $this->parser;
    $stream = $parser->getStream();
    
    $name = $stream->expect(Twig_Token::NAME_TYPE)->getValue();
    $stream->expect(Twig_Token::OPERATOR_TYPE, '=');
    $value = $parser->getExpressionParser()->parseExpression();
    $stream->expect(Twig_Token::BLOCK_END_TYPE);
    
    return new Project_Set_Node($name, $value, $token->getLine(), $this->getTag());
  }
  
  public function getTag()
  {
    return 'set';
  }
}
```

Метод ```getTag()``` должен возвращать название тега, которое мы хотим использовать, в нашем случае - ```set```. 

Метод ```parse()``` будет вызван каждый раз, когда будет встречаться тег ```set```. Метод должен возвращать экземпляр класса ```Twig_Node```, который представляет собой узловой элемент (создание ```Project_Set_Node``` будет рассмотрено позднее). 

Процесс парсинга упрощён благодаря использованию некоторых методов, которые можно вызвать из потока (```$this->parser->getStream()```):

- ```getCurrent()```: возвращает текущий токен в потоке.
- ```next()```: Перемещается к новому токену в потоке, но возвращает предыдущий токен.
- ```test($type)```, ```test($value)```, ```test($type, $value)```: проверяет, если текущий токен является определенного типа и равен определенному значению. ```$value``` может быть массивом допустимых значений.
- ```expect($type[, $value, [, $message]])```: если текущий токен не является определенного типа или значения, то будет выброшено исключение. Если токен является определенного типа и значения, то он будет возвращен и поток перейдёт к следующему токену.
- ```look()```: просматривает следующий токен без его обработки.

Парсинг выражения выполняется посредством вызова метода ```parseExpression()```.

Изучение кода существующих классов ```Token_Parser``` это лучший способ изучить мельчайшие особенности написания и создания собственных тегов и самого процесса парсинга.

###### Определение узла

Класс ```Project_Set_Node``` достаточно простой сам по себе:

```php
class Project_Set_Node extends Twig_Node
{
  public function __construct($name, Twig_Node_Expression $value, $line, $tag = null)
  {
    pareturn::__construct(array('value' => $value), array('name' => $name), $line, $tag);
  }
  
  public function compile(Twig_Compiler $compiler)
  {
    $compiler
      ->addDebugInfo($this)
      ->write('$context[\''.$this->getAttribute('name').'\'] = ')
      ->subcompile($this->getNode('value'))
      ->raw(';\n')
  }
}
```

Компилятор реализует гибкий интерфейс и предоставляет разработчику методы, которые позволяют генерировать красивый и легко читаемый PHP-код:

- ```subcompile()```: компилирует узел.
- ```raw()```: выводит указанную строку в исходном виде.
- ```write()```: выводит указанную строку добавляя отступ в начале каждой строки.
- ```string()```: выводит строку в кавычках.
- ```repr()```: выводит PHP-представление переданного значения.
- ```addDebugInfo()```: добавляет строку из оригинального файла шаблона в текущий узел в качестве комментария.
- ```indent()```: форматирует генерируемый код.
- ```outdent()```: отменяет форматирование сгенерированного кода.

###### Создаём расширение

Наиболее частая причина написания расширений это перенос часто используемого кода в удобные для переиспользования классы, например, как в случае с локализацией. Расширение может определять теги, фильтры, тесты, операторы, глобальные переменные, функции, и обработчики узлов.

Чаще всего будет значительно удобнее хранить все ваши дополнения, вроде тегов, функций или тестов, в едином расширении для вашего проекта. 

При упаковке кода в дополнения, Twig достаточно умён, чтобы при каждом изменении исходного кода осуществить перекомпиляцию (при активной опции ```auto_reload```).

Перед тем как писать собственные расширения, взгляните на официальный репозиторий: [http://github.com/twigphp/Twig-extensions](http://github.com/twigphp/Twig-extensions).

Расширение представляет собой класс, который должен реализовывать следующий интерфейс:

```php
interface Twig_ExtensionInterface
{
  /**
  * Возвращает экземпляр парсера токенов для добавление к существующему списку.
  * @return Twig_TokenParserInterface[]
  */
  public function getTokenParsers();
  
  /**
  * Возвращает экземпляр просмотрщика узлов для добавления к существующему списку.
  * @return Twig_NodeVisitorInterface[]
  */
  public function getNodeVisitors();
  
  /**
  * Возвращает список фильтров для добавления к существующему списку.
  * @return Twig_Filter[]
  */
  public function getFilters();
  
  /**
  * Возвращает список тестов для добавления к существующему списку.
  * @return Twig_Test[]
  */
  public function getTests();
  
  /**
  * Возвращает список функций для добавления к существующему списку.
  * @return Twig_Funstion[]
  */
  public function getFunctions();
  
  /**
  * Возвращает список операторов для добавления к существующему списку.
  * @return array<array> Первый массив - массив унарных операторов, второй массив - бинарных операторов.
  */
  public function getOperators();
}
```

Для поддержания чистоты и простоты, рекомендуется наследовать собственный класс расширения от ```Twig_Extension```:

```php
class Project_Twig_Extension extends Twig_Extendion {}
```

Конечно же очевидно, что такое расширение не обладает полезными функциями, но этим мы займёмся в следующем разделе. Twig не оглашает жестких требований к расположения файла расширения, потому что каждое расширение должно быть зарегистрировано в среде окружения явно.

Для регистрации расширения достаточно вызвать метод ```addExtension()``` экземпляра класса ```Twig_Environment```:

```php
$twig = new Twig_Environment($loader);
$twig->addExtension(new Project_Twig_Extension());
```

Расширения Twig, которые поставляются по-умолчанию являются замечательным примером того, как должны работать расширения.

###### Глобальные переменные

Глобальные переменные могут быть зарегистрированы в расширении при помощи метода ```getGlobals()```:

```php
class Project_Twig_Extension extends Twig_Extension implements Twig_Extension_GlobalsInterface
{
  public function getGlobals()
  {
    return array(
      'text' => new Text()
    );
  }
  
  // ...
}
```

###### Функции

Функции могут быть зарегистрированы в расширении при помощи метода ```getFunctions()```:

```php
class Project_Twig_Extension extends Twig_Extension
{
  public function getFunctions()
  {
    return array(
      new Twig_Function('lipsum', 'generate_lipsum')
    );
  }
  
  // ...
}
```

###### Фильтры

Фильтры могут быть зарегистрированы в расширении при помощи метода ```getFilters()```:

```php
class Project_Twig_Extension extends Twig_Extension
{
  public function getFilters()
  {
    return array(
      new Twig_Filter('rot13', 'str_rot13')
    );
  }
  
  // ...
}
```

###### Теги

Теги могут быть зарегистрированы в расширении при помощи метода ```getTokenParsers()```:

```php
class Project_Twig_Extension extends Twig_Extension
{
  public function getTokenParsers()
  {
    return array(
      new Project_Set_TokenParser()
    );
  }
  
  // ...
}
```

В приведенном выше коде мы добавили только один тег, определенный классом ```Project_Set_TokenParser```. Класс ```Project_Set_TokenParser``` отвечает за парсинг и компилирование тега в код PHP-представления.

###### Операторы

Метод ```getOperators()``` позволяет добавить новые операторы. Вот, например, как будет выглядеть добавление ```!```, ```||```, ```&&```:

```php
class Project_Twig_Extension extends Twig_Extension
{
  public function getOperators()
  {
    return array(
      array(
        '!' => array('precedence' => 50, 'class' => 'Twig_Node_Expression_Unary_Not'),
      ),
      array(
        '||' => array('precedence' => 10, 'class' => 'Twig_Node_Expression_Binary_Or', 'associativity' => Twig_ExpressionParser::OPERATOR_LEFT),
        '&&' => array('precedence' => 15, 'class' => 'Twig_Node_Expression_Binary_And', 'associativity' => Twig_ExpressionParser::OPERATOR_LEFT)
      ),
    );
  }
  
  // ...
}
```

###### Тесты

Метод ```getTests()``` позволяет добавить новые тесты:

```php
class Project_Twig_Extension extends Twig_Extension
{
  public function getTests()
  {
    return array(
      new Twig_Test('even', 'twig_test_even'),
    );
  }
}
```

###### Определять заранее или во время выполнения

Фильтры, функции или тесты могут быть определены на этапе выполнения и быть типа ```callable```:

- функции или статичные методы: быстрые для реализации и простые; сложности заключаются в зависимостях от других объектов на этапе выполнения.
- замыкания (```closure```): просты в реализации;
- методы объектов: предоставляют большую гибкость, если выполнение кода зависит от состояния внешних объектов.

Самый простой способ определить метод, это описать его прямо в классе расширения:

```php
class Project_Twig_Extension extends Twig_Extension
{
  private $rot13Provider;
  
  public function __construct($rot13Provider)
  {
    $this->rot13Provider = $rot13Provider;
  }
  
  public function getFunctions()
  {
    return array(
      new Twig_Function('rot13', array($this, 'rot13')),
    );
  }
  
  public function rot13($value)
  {
    return $rot13Provider->rot13($value);
  }
}
```

Это очень простой и понятный способ, однако он не рекомендован для реализации потому, что ставит компиляцию шаблона в зависимость от внешнего объекта, которая может быть и вовсе не нужна. 

У вас есть возможность разделить определение от реализации через регистрацию экземпляра класса ```Twig_RuntimeLoaderIntarface``` и зарегистрировать в среде окружения, которая уже знает, как инициировать экземпляры определенного класса:

```php
class RuntimeLoader extends Twig_RuntimeLoaderInterface
{
  public function load($class)
  {
    // реализуйте логику инициирования класса $class
    // и внедрение зависимостей
    // в большинстве случаев это означает использование собственного контейнера зависимостей
    if ('Project_Twig_RuntimeExtension' === $class) {
      return new $class(new Rot13Provider);
    } else {
      // ...
    }
  }
}

$twig->addRuntimeLoader(new RuntimeLoader());
```

Twig поставляется с [PSR-11 совместимым загрузчиком](http://www.php-fig.org/psr/psr-11/) ```Twig_ContainerRuntimeLoader```.

Теперь возможен перенос логики этапа выполнения в новый класс ```Project_Twig_RuntimeExtension``` и прямое использование прямо в расширении:

```php
class Project_Twig_RuntimeExtension
{
  private $rot13Provider;
  
  public function __construct($rot13Provider)
  {
    $this->rot13Provider = $rot13Provider;
  }
  
  public function rot13($value)
  {
    return $this->rot13Provider->rot13($value);
  }
}

class Project_Twig_Extension extends Twig_Extension
{
  public function getFunctions()
  {
    return array(
      new Twig_Function('rot13', array('Project_Twig_RuntimeExtension', 'rot13')),
      // или
      new Twig_Function('rot13', 'Project_Twig_RuntimeExtension::rot13'),
    );
  }
}
```

###### Перегрузка

Чтобы переопределить / перегрузить существующие фильтры, функции, тесты, операторы или глобальные переменные, необходимо добавить новое определение _после_ переобределяемой сущности (порядок имеет значение).

```php
class MyCoreExtension extends Twig_Extension
{
  public function getFilters()
  {
    return array(
      new Twig_Filter('date', array($this, 'dateFilter')),
    );
  }
  
  public function dateFilter($timestamp, $format = 'Y/m/d H:i:s')
  {
    // ...
  }
}

$twig = new Twig_Exnvironment($loader);
$twig->addExtension(new MyCoreExtension());
```

В приведённом выше коде мы переобпределили встроенный фильтр ```date```.

Учтите, что при добавлении фильтра непосредственно в среду окружения ```Twig_Environment```, приоритетность выше у встроенных сущностей, а не регистрируемых позже расширений:

```php
$twig = new Twig_Environment($loader);
$twig->addFilter(new Twig_Filter('date', function($timestamp, $format = 'Y/m/d H:i:s') {
  // ...
}));

// определение фильтра date будет использовано из приведенного выше, а не добавляемого через расширение ниже
$twig->addExtension(new MyCoreExtension());
```

Имейте ввиду, что переопределение встроенных элементов Twig не является рекомендованным, так как в дальнейшем может привести к путанице.

###### Тестирование расширений

- Функциональное тестирование

Для создание функциональных тестов расширений достаточно воссоздать следующую структуру директорий в тестовой директории:

```twig
Fixtures/
  filters/
    foo.test
    bar.test
  functions/
    foo.test
    bar.test
  tags/
    foo.test
    bar.test
IntegrationTest.php
```

Файл ```IntegrationTest.php``` должен выглядеть следующим образом:

```php
class Project_Tests_IntegrationTest extends Twig_Test_IntegrationTestCase
{
  public function getExtensions()
  {
    return array(
      new Project_Twig_Extension1(),
      new Project_Twig_Extension2(),
    );
  }
  
  public function getFixturesDir()
  {
    return dirname(__FILE__) . '/Fixtures/';
  }
}
```

- Тестирование узлов

Тестирование просмотрщика узлов может быть достаточно сложной задаче, используется класс ```Twig_Test_NodeTestCase```. Примеры могут быть найдены по ссылке [https://github.com/twigphp/Twig/tree/master/test/Twig/Tests/Node](https://github.com/twigphp/Twig/tree/master/test/Twig/Tests/Node).
