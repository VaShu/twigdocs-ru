Текущая глава описывает синтакс и семантику шаблонизатора Twig и будет наиболее полезна в качестве справочника тем, кто занимается разработкой шаблонов.

### **Краткий обзор**

Шаблон представляет собой обычный текстовый файл. Шаблонизатор поддерживает любой текстовый формат - XHTML, XML, CSV, LaTeX и др. Определенные требования к расширению файла отсутствуют, он может быть как с расширением ```.html```, так и с ```.xml``` - оба варианта подойдут. 

Шаблон содержит _переменные_ и _выражения_, которые во время анализа заменяются на соответствующие значения. Так же в шаблоне могут присутствовать ```теги```, которые влияют на логику выполнения (обработки) шаблона.

Ниже представлен минимальный пример шаблона, который позволит наглядно продемонстрировать некоторые основы:
```twig
<!DOCTYPE html>
<html>
  <head>
    <title>My Webpage</title>
  </head>
  <body>
    <ul id="navigation">
      {% for item in navigation %}
        <li><a href="{{ item.href }}">{{ item.caption }}</a></li> {% endfor %}
    </ul>
    <h1>My Webpage</h1>
    {{ a_variable }}
  </body>
</html>
```

Существует три вида разделителей:
- ```{% ... %}``` : предназначен для выполнения команд, например, присвоения (```set```) или циклов.
- ```{{ ... }}``` : предназначен для вывода значений в шаблон.
- ```{# ... #}``` : предназначен для комментариев.

### **Интеграции с IDE**

Большинство современных редакторов кода поддерживают подсветку синтаксиса и автодополнения Twig. 

Например:
- Textmate через Twig bundle
- Netbeans через Twig syntax plugin
- PhpStorm (встроенная поддержка)
- Visual Studio Code через Twig pack.

Полезный сервис - [TwigFiddle](https://twigfiddle.com/), который позволит выполнить и изучить результат работы шаблонизатора прямо в браузере.

### **Переменные**

Приложение передаёт переменные в шаблон для управления логикой отображения и самим отображением. Переменные могут содержать аттрибуты и свойства (элементы) к которым вы можете получить доступ прямо из шаблона. То, как будет выглядеть переменная в шаблона сильно зависит от используемого приложения и того, как само приложение передаёт / описывает передаваемые переменные.

Для доступа к аттрибутам переменной (методам, свойствам PHP объектов или массивам) можно воспользоваться символом точки - ```.```, или так называемым "индексным доступом" - ```[]```.
```twig
{{ foo.bar }}
{{ foo["bar"] }}
```

В случае, если аттрибут содержит специальные символы, например, знак минуса ```-```, то необходимо воспользоваться функцией ```attribute```, вместо использования ```.```:
```twig
{{ attribute(foo, "data-foo") }}
```

_Пояснение_: использование символа ```-``` и доступа к аттрибуту через ```.``` приводит к некорректному интерпретированию выражения:
```twig
{{ foo.data-bar }}
```

Анализатор воспримет ```foo.data``` как одну переменну, из значения которой вычитают значение другой переменной - ```bar```.

Если переменная или свойство не существует, то результатирующим значением будет значение ```null``` при отключенном режиме ```strict_variables``` (равен ```false```). В случае активированного режима ```strict_variables``` (равен ```true```) Twig выбросит исключение (см. настройки окружения).

_Реализация_:
Ради удобства использования ```foo.bar```, осуществляются следующие проверки на уровне PHP:

- проверка, что ```foo``` это массив, а ```bar``` действительный элемент;
- если нет, то проверка того, что ```foo``` это объект, а ```bar``` действительное свойство;
- если нет, то проверка того, что ```foo``` это объект, а ```bar``` действительный метод;
- если нет, то проверка того, что ```foo``` это объект, а ```getBar``` действительный метод;
- если нет, то проверка того, что ```foo``` это объект, а ```isBar``` действительный метод;
- если нет, то проверка того, что ```foo``` это объект, а ```hasBar``` действительный метод;
- если нет, то вернуть значение ```null```.

В то же время ```foo["bar"]``` работает только с PHP-массивами:

- проверка, что ```foo``` это массив и ```bar``` действительный элемент;
- если нет, то вернуть значение ```null```.

Если есть необходимость обращения к динамическим аттрибутам, то рекомендуется использовать функцию ```attribute```.

**Глобальные переменные**

Следующие переменные всегда доступны в шаблонах:

- ```_self```: ссылается на текущее название шаблона.
- ```_context```: ссылается на текущий контекст.
- ```_charset```: ссылается на текущую кодировку.

Пример:

```twig
Значение переменной _self : {{ _self }}
Значение переменной _context : {{ _context }}
Значение переменной _charset : {{ _charset }}
```

Результат:

```twig
Значение переменной _self : main.twig
Значение переменной _context : Array
Значение переменной _charset : UTF-8
```

**Присваивание значений переменным**

Присваивать значения переменным можно в блоках ```{% ... %}``` использую тег ```set```:

```twig
{% set foo = 'foo' %}
{% set foo = [1, 2] %}
{% set foo = {'foo': 'bar'} %}
```

### **Фильтры**
Переменные могут быть изменены фильтрами. Фильтры отделяются от переменных символом ```|``` (pipe symbol) и могут иметь опциональные аргументы в скобках. Фильтры можно объединять (связывать). Результат выполнение одного фильтра передаётся на вход следующему. 

В данном примере происходит удаление HTML-тегов из переменной ```name``` и последующая смена всех символов на их заглавные версии:

```twig
{{ name|striptags|title }}
```

Фильтры, которые принимают дополнительные аргументы, содержат перечень этих аргументов между ```(``` и ```)``` скобками. В приведённом примере список значений будет объединён символом запятой:

```twig
{{ list|join(', ') }}
```

Чтобы применить фильтр к секции кода воспользуйтесь тегом ```filter```:
```twig
{% filter upper %}
  Этот текст будет отображаться со всеми заглавными буквами.
{% endfilter %}
```

Со списком всех доступных фильтров можно ознакомиться [по этой ссылке](https://twig.symfony.com/doc/2.x/).

### **Функции**

Функции могут быть вызваны для генерирования содержимого шаблонов и состоят из имени, скобок и опционального списка аргументов.

Для примера, функция ```range``` возвращает массив чисел от начального значения до конечного с определенным шагом:

```twig
{% for i in range(0, 3) %}
  {{ i }},
{% endfor %}
```

Со списком всех доступных функций можно ознакомиться [по этой ссылке](https://twig.symfony.com/doc/2.x/).

### **Именованые аргументы**

```twig
{% for i in range(low=1, high=10, step=1) %}
  {{ i }},
{% endfor %}
```

Использование именованных аргументов делает вызов в шаблоне понятным и даёт дополнительную информацию о предназначении передаваемых параметров:

```twig
{{ data|convert_encoding('UTF-8', 'iso-2022-jp') }}

{# или #}

{{ data|convert_encoding(from='UTF-8', to='iso-2022-jp') }}
```

Именованные аргументы так же позволяют пропустить некоторые из передаваемых аргументов, для которых вы не хотите менять значения по-умолчанию:

```twig
{# первый аргумент отвечает за формт даты и при передаче значения null используется глобальный формат #}
{{ "now"|date(null, "Europe/Paris") }}

{# ... а вот как будет выглядеть вызов с использованием именованных аргументов #}
{{ "now"|date(timezone="Europe/Paris") }}
```

Безусловно есть возможность использования как именованных аргументов так и неименованных в одном вызове, однако необходимо помнить, что неименованные аргументы всегда должны следовать первыми:

```twig
{{ "now"|date("m.d.Y H:i:s", timezone="Europe/Paris") }}
```

На страницах документации, в описании каждого метода и фильтра, присутствует полный перечень поддерживаемых параметров и их наименований.

### **Управляющие структуры**

К управляющим структурам относятся всё то, что влияет на логику (течение) работы программы - условия (```if```, ```elseif```, ```else```), ```for```-циклы и блоки. Управляющие структуры используются между тегами ```{% ... %}```.

Например, чтобы отобразить список пользователей, которые хранятся в переменной ```users``` воспользуемся ```for```-тегом:

```twig
<h1>Members</h1>
<ul>
  {% for user in users %}
    <li>{{ user.username|e }}</li>
  {% endfor %}
</ul>
```

Тег ```if``` может быть использован для проверки выражений:

```twig
{% if users|length > 0 %}
  <ul>
    {% for user in users %}
      <li>{{ user.username|e }}</li>
    {% endfor %}
  </ul>
{% endif %}
```

Для ознакомления со всем перечнем поддерживаемых тегов перейдите [по этой ссылке](https://twig.symfony.com/doc/2.x/).

### **Комментарии**

Чтобы закомментировать часть кода или строки в шаблоне воспользуйтесь тегом ```{# ... #}```. Крайне полезная возможности при отладке или необходимости внесения дополнительных пояснений в логику отображения.

```twig
{# внимание: отключили отображение, больше его не используем в самом контроллере
  {% for user in users %}
    ...
  {% endfor %}
#}
```

### **Подключаем другие шаблоны**

Функция подключения шаблонов полезна тем, что с её помощью можно в существующий шаблон вставить содержимое другого шаблона для выполнение в текущем контексте:

```twig
{{ include('sidebar.html') }}
```

По-умолчанию включаемые шаблоны имеют доступ к тому же контексту в шаблоне которого они вызываются. Это означает, что любая переменная, объявленная в основном шаблоне, будет доступна и в подключаемом тоже:

```twig
{% for box in boxes %}
  {{ include('render_box.html') }}
{% endfor %}
```

Подключаемый шаблон ```render_box.html``` имеет доступ к переменной ```box```.

Наименование подключаемого шаблона зависит от использованного системного загрузчика. Для примера, ```Twig_Loader_Filesystem``` позволяет получить доступ к шаблону с указанием полного пути к файлу шаблона, а это значит, что есть возможность получить доступ к шаблону используя ```/``` для перехода в нужную директорию:

```twig
{{ include('/special/client/templates/sidebar.html') }}
```

Такая возможность, по использованию доступа к шаблону по пути в файловой системе относительно проекта, доступна в зависимости от настроек приложения использующего шаблонизатор Twig.

### **Наследование шаблонов**

Сильной стороной Twig является наличие наследования шаблонов. Наследование шаблонов позволяет создать своего рода "скелет" отображения, которое содержит все необходимые элементы сайта и определяет ```block```-теги (блоки), которые дочерние шаблоны могут перезаписывать и переопределять.

Звучит ужасающе, но всё намного проще! Лучше способ понять - начать с небольшого примера.

Давайте определим базовый шаблон, ```base.html```,  который описывает общую HTML-структуру страницы с двумя колонками, которую вы могли бы использовать у себя на сайте:

```twig
<!DOCTYPE html>
<html>
  <head>
    {% block head %}
      <link rel="stylesheet" href="style.css" />
      <title>{% block title %}{% endblock %} - My webpage</title>
    {% endblock %}
  </head>
  <body>
    <div id="content">{% block content %}{% endblock %}</div>
    <div id="footer">
      {% block footer %}
        (с) Copyright 2011 by <a href="http://example.com">me</a>
      {% endblock %}
    </div>
  </body>
</html>
```

В этом примере объявляются 4 блока, которые могут быть перезаписаны в дочерних шаблонах. Всё, что делают ```block```-теги, так это сообщают шаблонизатору о том, что у дочерних шаблонов есть возможность перезаписать содержимое этих блоков.

Дочерний шаблон, в свою очередь, может выглядеть следующим образом:

```twig
{% extends 'base.html' %}

{% block title %}Index{% endblock %}
{% block head %}
  {{ parent() }}
  <style type="text/css">
    .important { color: blue }
  </style>
{% endblock %}
{% block content %}
  <h1>Index</h1>
  <p class="important">
    Welcome to my awesome page!
  </p>
{% endblock %}
```

Ключевым здесь является ```extends```-тег. Этот тег сообщает шаблонизатору, что текущий шаблон "расширяет" / наследуется от другого шаблона. На момент анализа шаблона система, в первую очередь, определяет родительский шаблон. ```extends```-тег должен быть первым тегом в шаблоне.

Обратите внимание, что дочерний шаблон не определяет блок ```footer```, это значит, что будет использовано содержимое родительского шаблона. 

Есть возможность отобразить содержимое родительского блока при помощи вызова функции ```parent()```. Вызов этой функции возвращает содержимое родительского блока:

```twig
{% block sidebar %}
  <h3>Table of contents</h3>
  ...
  {{ parent() }}
{% endblock %}
```

[Страница документации](https://twig.symfony.com/doc/2.x/tags/extends.html) по ```extends```-тегу описывает значительно подробнее расширенные возможности тега - вложенные блоки, области видимости, динамическое наследование, условное наследование.

Twig так же поддерживает множественное наследование по так называемой методике "горизонтального переиспользование" (horizontal reuse) с помощью ```use```-тега. В большинстве случаев вам даже не понадобится погружаться так глубоко и использовать этот подход при проектировании шаблонов.
