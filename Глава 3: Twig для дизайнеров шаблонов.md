Текущая глава описывает синтакс и семантику шаблонизатора Twig и будет наиболее полезна в качестве справочника тем, кто занимается разработкой шаблонов.

### **Краткий обзор**

Шаблон представляет собой обычный текстовый файл. Шаблонизатор поддерживает любой текстовый формат - XHTML, XML, CSV, LaTeX и др. Определенные требования к расширению файла отсутствуют, он может быть как с расширением ```.html```, так и с ```.xml``` - оба варианта подойдут. 

Шаблон содержит _переменные_ и _выражения_, которые во время анализа заменяются на соответствующие значения. Так же в шаблоне могут присутствовать ```теги```, которые влияют на логику выполнения (обработки) шаблона.

Ниже представлен минимальный пример шаблона, который позволит наглядно продемонстрировать некоторые основы:
```twig
<!DOCTYPE html>
<html>
  <head>
    <title>My Webpage</title>
  </head>
  <body>
    <ul id="navigation">
      {% for item in navigation %}
        <li><a href="{{ item.href }}">{{ item.caption }}</a></li> {% endfor %}
    </ul>
    <h1>My Webpage</h1>
    {{ a_variable }}
  </body>
</html>
```

Существует три вида разделителей:
- ```{% ... %}``` : предназначен для выполнения команд, например, присвоения (```set```) или циклов.
- ```{{ ... }}``` : предназначен для вывода значений в шаблон.
- ```{# ... #}``` : предназначен для комментариев.

### **Интеграции с IDE**

Большинство современных редакторов кода поддерживают подсветку синтаксиса и автодополнения Twig. 

Например:
- Textmate через Twig bundle
- Netbeans через Twig syntax plugin
- PhpStorm (встроенная поддержка)
- Visual Studio Code через Twig pack.

Полезный сервис - [TwigFiddle](https://twigfiddle.com/), который позволит выполнить и изучить результат работы шаблонизатора прямо в браузере.

### **Переменные**

Приложение передаёт переменные в шаблон для управления логикой отображения и самим отображением. Переменные могут содержать аттрибуты и свойства (элементы) к которым вы можете получить доступ прямо из шаблона. То, как будет выглядеть переменная в шаблона сильно зависит от используемого приложения и того, как само приложение передаёт / описывает передаваемые переменные.

Для доступа к аттрибутам переменной (методам, свойствам PHP объектов или массивам) можно воспользоваться символом точки - ```.```, или так называемым "индексным доступом" - ```[]```.
```twig
{{ foo.bar }}
{{ foo["bar"] }}
```

В случае, если аттрибут содержит специальные символы, например, знак минуса ```-```, то необходимо воспользоваться функцией ```attribute```, вместо использования ```.```:
```twig
{{ attribute(foo, "data-foo") }}
```

_Пояснение_: использование символа ```-``` и доступа к аттрибуту через ```.``` приводит к некорректному интерпретированию выражения:
```twig
{{ foo.data-bar }}
```

Анализатор воспримет ```foo.data``` как одну переменну, из значения которой вычитают значение другой переменной - ```bar```.

Если переменная или свойство не существует, то результатирующим значением будет значение ```null``` при отключенном режиме ```strict_variables``` (равен ```false```). В случае активированного режима ```strict_variables``` (равен ```true```) Twig выбросит исключение (см. настройки окружения).

_Реализация_:
Ради удобства использования ```foo.bar```, осуществляются следующие проверки на уровне PHP:

- проверка, что ```foo``` это массив, а ```bar``` действительный элемент;
- если нет, то проверка того, что ```foo``` это объект, а ```bar``` действительное свойство;
- если нет, то проверка того, что ```foo``` это объект, а ```bar``` действительный метод;
- если нет, то проверка того, что ```foo``` это объект, а ```getBar``` действительный метод;
- если нет, то проверка того, что ```foo``` это объект, а ```isBar``` действительный метод;
- если нет, то проверка того, что ```foo``` это объект, а ```hasBar``` действительный метод;
- если нет, то вернуть значение ```null```.

В то же время ```foo["bar"]``` работает только с PHP-массивами:

- проверка, что ```foo``` это массив и ```bar``` действительный элемент;
- если нет, то вернуть значение ```null```.

Если есть необходимость обращения к динамическим аттрибутам, то рекомендуется использовать функцию ```attribute```.

**Глобальные переменные**

Следующие переменные всегда доступны в шаблонах:

- ```_self```: ссылается на текущее название шаблона.
- ```_context```: ссылается на текущий контекст.
- ```_charset```: ссылается на текущую кодировку.

Пример:

```twig
Значение переменной _self : {{ _self }}
Значение переменной _context : {{ _context }}
Значение переменной _charset : {{ _charset }}
```

Результат:

```twig
Значение переменной _self : main.twig
Значение переменной _context : Array
Значение переменной _charset : UTF-8
```

**Присваивание значений переменным**

Присваивать значения переменным можно в блоках ```{% ... %}``` использую тег ```set```:

```twig
{% set foo = 'foo' %}
{% set foo = [1, 2] %}
{% set foo = {'foo': 'bar'} %}
```

### **Фильтры**
Переменные могут быть изменены фильтрами. Фильтры отделяются от переменных символом ```|``` (pipe symbol) и могут иметь опциональные аргументы в скобках. Фильтры можно объединять (связывать). Результат выполнение одного фильтра передаётся на вход следующему. 

В данном примере происходит удаление HTML-тегов из переменной ```name``` и последующая смена всех символов на их заглавные версии:

```twig
{{ name|striptags|title }}
```

Фильтры, которые принимают дополнительные аргументы, содержат перечень этих аргументов между ```(``` и ```)``` скобками. В приведённом примере список значений будет объединён символом запятой:

```twig
{{ list|join(', ') }}
```

Чтобы применить фильтр к секции кода воспользуйтесь тегом ```filter```:
```twig
{% filter upper %}
  Этот текст будет отображаться со всеми заглавными буквами.
{% endfilter %}
```

Со списком всех доступных фильтров можно ознакомиться [по этой ссылке](https://twig.symfony.com/doc/2.x/).

### **Функции**

Функции могут быть вызваны для генерирования содержимого шаблонов и состоят из имени, скобок и опционального списка аргументов.

Для примера, функция ```range``` возвращает массив чисел от начального значения до конечного с определенным шагом:

```twig
{% for i in range(0, 3) %}
  {{ i }},
{% endfor %}
```

Со списком всех доступных функций можно ознакомиться [по этой ссылке](https://twig.symfony.com/doc/2.x/).

### **Именованые аргументы**

```twig
{% for i in range(low=1, high=10, step=1) %}
  {{ i }},
{% endfor %}
```

Использование именованных аргументов делает вызов в шаблоне понятным и даёт дополнительную информацию о предназначении передаваемых параметров:

```twig
{{ data|convert_encoding('UTF-8', 'iso-2022-jp') }}

{# или #}

{{ data|convert_encoding(from='UTF-8', to='iso-2022-jp') }}
```

Именованные аргументы так же позволяют пропустить некоторые из передаваемых аргументов, для которых вы не хотите менять значения по-умолчанию:

```twig
{# первый аргумент отвечает за формт даты и при передаче значения null используется глобальный формат #}
{{ "now"|date(null, "Europe/Paris") }}

{# ... а вот как будет выглядеть вызов с использованием именованных аргументов #}
{{ "now"|date(timezone="Europe/Paris") }}
```

Безусловно есть возможность использования как именованных аргументов так и неименованных в одном вызове, однако необходимо помнить, что неименованные аргументы всегда должны следовать первыми:

```twig
{{ "now"|date("m.d.Y H:i:s", timezone="Europe/Paris") }}
```

На страницах документации, в описании каждого метода и фильтра, присутствует полный перечень поддерживаемых параметров и их наименований.

### **Управляющие структуры**

К управляющим структурам относятся всё то, что влияет на логику (течение) работы программы - условия (```if```, ```elseif```, ```else```), ```for```-циклы и блоки. Управляющие структуры используются между тегами ```{% ... %}```.

Например, чтобы отобразить список пользователей, которые хранятся в переменной ```users``` воспользуемся ```for```-тегом:

```twig
<h1>Members</h1>
<ul>
  {% for user in users %}
    <li>{{ user.username|e }}</li>
  {% endfor %}
</ul>
```

Тег ```if``` может быть использован для проверки выражений:

```twig
{% if users|length > 0 %}
  <ul>
    {% for user in users %}
      <li>{{ user.username|e }}</li>
    {% endfor %}
  </ul>
{% endif %}
```

Для ознакомления со всем перечнем поддерживаемых тегов перейдите [по этой ссылке](https://twig.symfony.com/doc/2.x/).

### **Комментарии**

Чтобы закомментировать часть кода или строки в шаблоне воспользуйтесь тегом ```{# ... #}```. Крайне полезная возможности при отладке или необходимости внесения дополнительных пояснений в логику отображения.

```twig
{# внимание: отключили отображение, больше его не используем в самом контроллере
  {% for user in users %}
    ...
  {% endfor %}
#}
```

### **Подключаем другие шаблоны**

Функция подключения шаблонов полезна тем, что с её помощью можно в существующий шаблон вставить содержимое другого шаблона для выполнение в текущем контексте:

```twig
{{ include('sidebar.html') }}
```

По-умолчанию включаемые шаблоны имеют доступ к тому же контексту в шаблоне которого они вызываются. Это означает, что любая переменная, объявленная в основном шаблоне, будет доступна и в подключаемом тоже:

```twig
{% for box in boxes %}
  {{ include('render_box.html') }}
{% endfor %}
```

Подключаемый шаблон ```render_box.html``` имеет доступ к переменной ```box```.

Наименование подключаемого шаблона зависит от использованного системного загрузчика. Для примера, ```Twig_Loader_Filesystem``` позволяет получить доступ к шаблону с указанием полного пути к файлу шаблона, а это значит, что есть возможность получить доступ к шаблону используя ```/``` для перехода в нужную директорию:

```twig
{{ include('/special/client/templates/sidebar.html') }}
```

Такая возможность, по использованию доступа к шаблону по пути в файловой системе относительно проекта, доступна в зависимости от настроек приложения использующего шаблонизатор Twig.

### **Наследование шаблонов**

Сильной стороной Twig является наличие наследования шаблонов. Наследование шаблонов позволяет создать своего рода "скелет" отображения, которое содержит все необходимые элементы сайта и определяет ```block```-теги (блоки), которые дочерние шаблоны могут перезаписывать и переопределять.

Звучит ужасающе, но всё намного проще! Лучше способ понять - начать с небольшого примера.

Давайте определим базовый шаблон, ```base.html```,  который описывает общую HTML-структуру страницы с двумя колонками, которую вы могли бы использовать у себя на сайте:

```twig
<!DOCTYPE html>
<html>
  <head>
    {% block head %}
      <link rel="stylesheet" href="style.css" />
      <title>{% block title %}{% endblock %} - My webpage</title>
    {% endblock %}
  </head>
  <body>
    <div id="content">{% block content %}{% endblock %}</div>
    <div id="footer">
      {% block footer %}
        (с) Copyright 2011 by <a href="http://example.com">me</a>
      {% endblock %}
    </div>
  </body>
</html>
```

В этом примере объявляются 4 блока, которые могут быть перезаписаны в дочерних шаблонах. Всё, что делают ```block```-теги, так это сообщают шаблонизатору о том, что у дочерних шаблонов есть возможность перезаписать содержимое этих блоков.

Дочерний шаблон, в свою очередь, может выглядеть следующим образом:

```twig
{% extends 'base.html' %}

{% block title %}Index{% endblock %}
{% block head %}
  {{ parent() }}
  <style type="text/css">
    .important { color: blue }
  </style>
{% endblock %}
{% block content %}
  <h1>Index</h1>
  <p class="important">
    Welcome to my awesome page!
  </p>
{% endblock %}
```

Ключевым здесь является ```extends```-тег. Этот тег сообщает шаблонизатору, что текущий шаблон "расширяет" / наследуется от другого шаблона. На момент анализа шаблона система, в первую очередь, определяет родительский шаблон. ```extends```-тег должен быть первым тегом в шаблоне.

Обратите внимание, что дочерний шаблон не определяет блок ```footer```, это значит, что будет использовано содержимое родительского шаблона. 

Есть возможность отобразить содержимое родительского блока при помощи вызова функции ```parent()```. Вызов этой функции возвращает содержимое родительского блока:

```twig
{% block sidebar %}
  <h3>Table of contents</h3>
  ...
  {{ parent() }}
{% endblock %}
```

[Страница документации](https://twig.symfony.com/doc/2.x/tags/extends.html) по ```extends```-тегу описывает значительно подробнее расширенные возможности тега - вложенные блоки, области видимости, динамическое наследование, условное наследование.

Twig так же поддерживает множественное наследование по так называемой методике "горизонтального переиспользование" (horizontal reuse) с помощью ```use```-тега. В большинстве случаев вам даже не понадобится погружаться так глубоко и использовать этот подход при проектировании шаблонов.

### **Экранирование HTML**

Генерируя HTML-код всегда есть некоторая вероятного того, что в переменной будет содержаться HTML-разметка, которая повлияет на результат отображения. Существует два подхода к решению такой задачи: ручное экранирование каждой выводимой переменной и автоматическое экранирование всех выводимых переменных по-умолчанию.

Twig поддерживает оба варианта, а второй является вариантом используемым по-умолчанию.

Автоматическое экранирование может быть настроено с помощью тега ```autoescape``` и по-умолчанию работает с опцией ```html```.

**Ручное экранирование**

Если режим ручного экранирования переменных активен, то экранирование выводимых переменных ложится полностью на ваши плечи. Что экранировать? Любую перменную, содержимому которой вы не доверяете.

Экранирование работает через использование соответствующих фильтров - ```escape``` и ```e```.

```twig
{{ user.username|e }}
```

По-умолчанию ```escape```-фильтр использует стратегию экранирования ```html```, однако, в зависимости от используемого контекста, есть возможность указать другие стратегии:

```twig
{{ user.username|e('js') }}
{{ user.username|e('css') }}
{{ user.username|e('url') }}
{{ user.username|e('html_attr') }}
```

**Автоматическое экранирование**

Независимо от того, включено или нет автоматическое экранирование, есть возможность указать конкретный блок кода, который должен экранироваться используя ```autoescape```-тег.

```twig
{% autoescape %}
  Всё в этом блоке будет автоматически экранировано с использованием HTML-стратегии.
{% endautoescape %}
```

По-умолчанию ```autoescape```-тег использует ```html```-стратегию экранирования.

Если необходимо отобразить переменную в другом контексте, то воспользуйтесь одной из имеющихся стратегий экранирования, как показано в примере:

```twig
{% autoescape 'js' %}
  Всё в этом блоке будет автоматически экранировано с использованием JS-стратегии.
{% endautoescape %}
```

**Экранирование**

Иногда может возникнуть необходимость проигнорировать выводимую часть шаблона, которую, при обычной логике обработки, шаблонизатор бы воспринял, как часть кода. Например, если используется синтаксис по-умолчанию и вы хотите вывести строку ```{{```, то необходимо воспользоваться небольшой уловкой:

```twig
{{ '{{' }}
```

Для больший секций кода, который необходимо проигнорироваться, есть смысл воспользвоаться [```verbatim```-тегом](https://twig.symfony.com/doc/2.x/tags/verbatim.html).

**Макросы**

Макросы сравнимы с функциями в обычных языках программирования. Они полезны в случаях, когда необходимо переиспользовать часто используемые блоки HTML-кода.

Макрос определяется ```macro```-тегом. Приведём небольшой пример макроса, который отображает элемент формы:

```twig
{% macro input(name, value, type, size) %}
  <input type="{{ type|default("text") }}" name="{{ name }}" value="{{ value|e }}" size="{{ size|default(20) }}">
{% endmacro %}
```

Макрос может быть определён в любом шаблон и импортирован с использованием ```import```-тега перед использованием:

```twig
{% import "forms.html" as forms %}

<p>{{ forms.input('username') }}</p>
```

Кроме того, вы можете имортировать единичный макрос из шаблона в текущий контекст воспользовавшись ```from```-тегом и, по необходимости, указанием псевдонима вызываемого макроса.

```twig
{% from "forms.html" import input as input_field %}

<dl>
  <dt>Username</dt>
  <dd>{{ input_field('username') }}</dd>
  <dt>Password</dt>
  <dd>{{ input_field('password', '', 'password') }}</dd>
</dl>
```

Значения по-умолчанию так же могут быть установлены при описании максроса:

```twig
{% macro input(name, value = "", type = "", size = 20) %}
  <input type="{{ type }}" name="{{ name }}" value="{{ value|e }}" size="{{ size }}">
{% endmacro %}
```

Если при вызове макроса передаются дополнительные параметры (вне описанных), то их значения будут доступны в переменной ```varargs```.

**Выражения**

Выражения в Twig могут быть повсюду. Они ведут себя таким же образом, как в PHP. Если вы не используете PHP, то всё равно будете чувствовать себя комфортно используя их.

Список операторов в порядке увеличения приоритета выполнения:

- ```b-and```
- ```b-xor```
- ```b-or```
- ```or```
- ```and```
- ```==```
- ```!=```
- ```<```
- ```>```
- ```>=```
- ```<=```
- ```in```
- ```matches```
- ```starts with```
- ```ends with```
- ```..```
- ```+```
- ```-```
- ```~```
- ```*```
- ```/```
- ```//```
- ```%```
- ```is```
- ```**```
- ```|```
- ```[]```
- ```.```

```twig
{% set greeting = 'Hello' %}
{% set name = 'Andrew' %}

{{ greeting ~ name|lower }} {# Hello andrew #}

{# воспользуйтесь скобками для изменения приоритета выполнения #}
{{ (greeting ~ name)|lower }} {# hello andrew #}
```

**Константы**

Самый простые выражения - константы. Константы представляют собой PHP-значения различны типов.

Какие существуют константы:

- ```"Hello World"```: Всё, что располагается между ординарными или двойными кавычками является строкой. 
- ```42 / 42.5```: целочисленное значение и значение с плавающей запятой.
- ```["foo", "bar"]```: массивы объявляются перечислением элементов обрамлённых квадратными скобками.
- ```{"foo" : "bar"}```: хэш-массивы объявляются перечислением пар ключ-значение обрамлённых фигурными скобками.
```twig
{'foo': 'foo', 'bar': 'bar'}

{foo: 'foo', bar: 'bar'}

{2: 'foo', 4: 'bar'}

{% set foo = 'foo' %}
{(foo): 'foo', (1+1): 'bar', (name ~ last): 'baz'}
```
- ```true/false```: ```true``` - истинное значение, ```false``` - ложное.
- ```null```: ```null``` обозначает отсутствуе какого-либо значения. Это значение возвращается в том случае, если переменная не существует. ```none``` это псевдоним ```null```.

Массивы и хэш-массивы могут быть вложенными:

```twig
{% set foo = [1, {'bar': 'z'}] %}
```

Использование одинарных кавычек или двойных никак не сказывается на производительности или скорости обработки, однако стоит иметь ввиду, что интерполяция переменных возможна только в строке обрамлённой двойными кавычками.

**Математические операторы**

Twig позволяет выполнять математические операции над переменными. Редко когда их использование необходимо в шаблонах, однако поддержка была реализована с целью соблюдения полноты реализации шаблонизатора.

Следующие операторы доступны:

- ```+```: сложение
- ```-```: вычитание
- ```/```: деление, возвращает значение с плавающей точкой
- ```%```: деление по модулю, возвращает целочисленный остаток от деления двух целочисленных значений
- ```//```: деление двух целочисленных значение, возвращает целое значение округлённой вниз
- ```*```: умножение
- ```**```: возведение в степень, возводит значение левого операнда в степень правого (```{{ 2 ** 3 }}``` = 8)

**Логические операторы**

Комбинирование нескольких выражений возможно при помощи следующих логических операторов:

- ```and```: и
- ```or```: или
- ```not```: не
- ```(выражение)```: группировка выражений для изменения приоритета

Операторы являются регистро-зависимыми.

**Сравнения**

Следующие операторы сравнения доступны в любых выражениях: ```==```, ```!=```, ```<```, ```>```, ```>=```, ```<=```.

Так же возможна проверка, если строка ```starts with``` (начинается с) или ```ends with``` (заканчивается на) определенное значение.

```twig
{% if 'Andrew' starts with 'A' %}
{% endif %}

{% if 'Andrew' ends with 'w' %}
{% endif %}
```

Для более сложных сравнений используется оператор ```matches```, который поддерживает регулярные выражения:

```twig
{% if phone matches '/^[\\d\\.]+$/' %}
{% endif %}
```

**Оператор содержания**

Оператор ```in``` осуществляет проверку на содержание.

Возвращает ```true```, если левый операнд содержится в правом:

```twig
{{ 1 in [1, 2, 3] }} {# true #}

{{ 'cd' in 'abcd' }} {# true #}
```

Использование данного оператора возможно с массивами, строками, объектами реализующими интерфейс ```Traversable```.

Для осуществления отрицательной проверки на содержание воспользуйтесь ```not in```:

```twig
{% if 1 not in [1, 2, 3] %}

{% if not (1 in [1, 2, 3, 4]) %}
```

**Оператор тестирования**

Оператор ```is``` осуществляет тестирование. Тестирование предназначено для проверки переменных соблюдению/выполнению определенных условий. Правый операнд - название теста:

```twig
{% if name is odd %}
{% endif %}
```

 Тесты могут принимать аргументы:
 
 ```twig
{% if posts.status is constant("Post::PUBLISHIED") %}
```

Тесты могут быть негативными / отрицательными с использованияем ```is not```:

```twig
{% if posts.status is not constant("Post::PUBLISHED") %}

{% if not (posts.status is constant("Post::PUBLISHED")) %}
```

**Другие операторы**

Следующие операторы не попадают ни в одну из перечисленных ранее категорий:

- ```|```: применяет фильтр
- ```..```: создаёт последовательности в которой левый операнд выступает начальным значением, а правый - конечным. Является синтаксическим сахаром для вызова функции ```range```): 
```twig
{{ 1..5 }}
{{ range(1, 5) }}
```
Обратите внимание, что при совместном использовании ```..``` и ```|``` необходимо воспользоваться круглыми скобками, в связи с приоритетностью выполнения операций:
```twig
(1..5)|join(', ')
```
- ```~```: преобразует операнды к строкам и объединяет.
- ```.```, ```[]```: получает значение аттрибута объекта
- ```?:```: тернарный оператор
- ```??```: null-сходящийся оператор:
```twig
{{ foo ?? 'no' }} {#  взвращает foo , если foo не равен null, в противном случае возвращает 'no' #}
```

**Интерполяция строк**

Интерполяция строк позволяет любому действительному выражению находится в строке с двойными кавычками для замены на вычисленное значение.

```twig
{{ "Hello, #{name}" }}
{{ "1 + 2 = #{ 1 + 2 }" }}
```

**Контроль пробелов**

Используйте тег ```spaceless`` для удаление всех пробелов в HTML-коде между HTML-тегами:

```twig
{% spaceless %}
  <p>
    <h1>
      Hello!
    </h1>
  </p>
{% endspaceless %}

{# выведет: <p><h1>Hello!</h1></p> #}
```

В дополнение к имеющемуся ```spaceless```-тегу есть возможность контролировать наличие пробелов на уровне единичных тегов. Используя специальный модификатор пробелов есть возможность контролировать отображение пробелов, как в начале, так и в конце выражения.

```twig
{% set value = 'no spaces' %}
{#- отсутствуют пробелы в начале и конце -#}
{%- if true -%}
  {{- value -}}
{%- endif -%}

{# выведет 'no spaces' #}
```

Приведенный выше пример демонстрирует стандартное поведение модификатора пробелов и возможность удаления пробелов вокруг тегов. Использование модификатора пробелов на одной из сторон приведёт к удалению всех пробелов на этой стороне до следующего HTML-тега.

```twig
{% set value = 'no spaces' %}
<li>    {{- value }}  </li>

{# выведет '<li>no spaces   </li>' #}
```

**Расширения**

Twig может быть очень просто расширен произвольными тегами, функциями и фильтрами. Если вы хотите воспользоваться уже разработанными community-расширениями, то обязательно загляните [в официальный репозиторий расширений](http://github.com/twigphp/Twig-extensions).

Если же вы хотите разработать собственные расширения, то изучите главу "Создание расширений".
