###### Отображение сообщений об устаревших методах

По-умолчанию такие уведомления возможно сгенерировать посредством вызова функции ```trigger_error()```, однако по-умолчанию этот метод ничего не записывает в логи и не отображает.

Чтобы исключить сообщения об устаревших методах во всех шаблонах можно написать и запустить такой скрипт:

```php
require_one __DIR__ . '/vendor/autoload.php';

$twig = create_your_twig_env();

$deprications = new Twig_Util_DepricationCollection($twig);

print_r($deprications->collectDir(__DIR__ . '/templates'));
```

Метод ```collectDir()``` компилирует все исходные шаблоны в указанной директории, отлавливает уведомления об устаревших методах и возвращает их.

Однако такой код не позволит найти все устаревшие методы (например, при использовании устаревших классов Twig). Для того, чтобы отследить все устаревшие методы и шаблоны, которые их используют, нам понадобится доработать код:

```php
$deprications = array();
set_error_handler(function($type, $msg) use (&$deprications){
  if (E_USER_DEPRICATED === $type) {
    $deprications[] = $msg;
  }
})

// запустите приложение

print_r($deprications);
```

Учитывайте, что все уведомления об устаревших методах буду генерироваться на этапе компиляции, поэтому на этапе выполнения, когда скомпилированный шаблон в кэше, таких уведомлений не будет.

###### Формируя макет по условию

Работая с Ajax некоторое содержимое необходимо вывести в том виде в котором оно есть, а некоторое необходимо преобразовать. Так как названия шаблонов в Twig могут быть любые действительные выражения результат которых строка, то у вас есть возможность управлять отображаемым или загружаемым шаблоном в зависимости от типа запроса:

```twig
{% extends request.ajax ? 'base_ajax.html' : 'base.html' %}

{% block content %}
{% endblock %}
```

###### Делаем подключение динамическим

При подключении шаблона его имя не обязательно должно быть строкой. Например, имя подгружаемого шаблона может зависеть от значения внешней переменной:

```twig
{% include var ~ '_base.html' %}
```

Допустим, что значение переменной ```var``` будет равно ```index```, это значит, что необходимо использовать шаблон ```index_base.html```. В действительности имя шаблона может быть любым выражением генерирующим в результате строковое значение:

```twig
{% include var|default('index') ~ '_foo.html' %}
```

###### Настраиваем синтаксис

Twig разрешает производить некоторые изменения в синтаксисе разделителей блоков. Это не рекомендуется делать по той причине, что шаблоны будут жестко привязаны к вашему синтаксису, однако для некоторых проектов такие изменения допустимы и необходимы.

Для изменения блоковых разделителей необходимо создать новый анализатор лексем:

```php
$twig = new Twig_Environment(...);

$lexer = new Twig_Lexer($twig, array(
  'tag_comment' => array('{#', '#}'),
  'tag_block' => array('{%', '%}'),
  'tag_variable' => array('{{', '}}'),
  'interpolation' => array('#{', '}'),
));
$twig->setLexer($lexer);
```

Вот некоторые примеры конфигураций симулирующих другие шаблонизаторы:

```php
 // Ruby erb syntax
$lexer = new Twig_Lexer($twig, 
  array( 
  'tag_comment' => array('<%#', '%>'), 
  'tag_block' => array('<%', '%>'), 
  'tag_variable' => array('<%=', '%>'),
));
```

```php
// SGML Comment Syntax
$lexer = new Twig_Lexer($twig, array( 
  'tag_comment' => array('<!--#', '-->'), 
  'tag_block' => array('<!--', '-->'), 
  'tag_variable' => array('${', '}'),
  ));
```

```twig
 // Smarty like
$lexer = new Twig_Lexer($twig, array( 
  'tag_comment' => array('{*', '*}'), 
  'tag_block' => array('{', '}'), 
  'tag_variable' => array('{$', '}'),
));
```
