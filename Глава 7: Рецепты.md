###### Отображение сообщений об устаревших методах

По-умолчанию такие уведомления возможно сгенерировать посредством вызова функции ```trigger_error()```, однако по-умолчанию этот метод ничего не записывает в логи и не отображает.

Чтобы исключить сообщения об устаревших методах во всех шаблонах можно написать и запустить такой скрипт:

```php
require_one __DIR__ . '/vendor/autoload.php';

$twig = create_your_twig_env();

$deprications = new Twig_Util_DepricationCollection($twig);

print_r($deprications->collectDir(__DIR__ . '/templates'));
```

Метод ```collectDir()``` компилирует все исходные шаблоны в указанной директории, отлавливает уведомления об устаревших методах и возвращает их.

Однако такой код не позволит найти все устаревшие методы (например, при использовании устаревших классов Twig). Для того, чтобы отследить все устаревшие методы и шаблоны, которые их используют, нам понадобится доработать код:

```php
$deprications = array();
set_error_handler(function($type, $msg) use (&$deprications){
  if (E_USER_DEPRICATED === $type) {
    $deprications[] = $msg;
  }
})

// запустите приложение

print_r($deprications);
```

Учитывайте, что все уведомления об устаревших методах буду генерироваться на этапе компиляции, поэтому на этапе выполнения, когда скомпилированный шаблон в кэше, таких уведомлений не будет.

###### Формируя макет по условию

Работая с Ajax некоторое содержимое необходимо вывести в том виде в котором оно есть, а некоторое необходимо преобразовать. Так как названия шаблонов в Twig могут быть любые действительные выражения результат которых строка, то у вас есть возможность управлять отображаемым или загружаемым шаблоном в зависимости от типа запроса:

```twig
{% extends request.ajax ? 'base_ajax.html' : 'base.html' %}

{% block content %}
{% endblock %}
```

###### Делаем подключение динамическим

При подключении шаблона его имя не обязательно должно быть строкой. Например, имя подгружаемого шаблона может зависеть от значения внешней переменной:

```twig
{% include var ~ '_base.html' %}
```

Допустим, что значение переменной ```var``` будет равно ```index```, это значит, что необходимо использовать шаблон ```index_base.html```. В действительности имя шаблона может быть любым выражением генерирующим в результате строковое значение:

```twig
{% include var|default('index') ~ '_foo.html' %}
```

###### Настраиваем синтаксис

Twig разрешает производить некоторые изменения в синтаксисе разделителей блоков. Это не рекомендуется делать по той причине, что шаблоны будут жестко привязаны к вашему синтаксису, однако для некоторых проектов такие изменения допустимы и необходимы.

Для изменения блоковых разделителей необходимо создать новый анализатор лексем:

```php
$twig = new Twig_Environment(...);

$lexer = new Twig_Lexer($twig, array(
  'tag_comment' => array('{#', '#}'),
  'tag_block' => array('{%', '%}'),
  'tag_variable' => array('{{', '}}'),
  'interpolation' => array('#{', '}'),
));
$twig->setLexer($lexer);
```

Вот некоторые примеры конфигураций симулирующих другие шаблонизаторы:

```php
 // Ruby erb syntax
$lexer = new Twig_Lexer($twig, 
  array( 
  'tag_comment' => array('<%#', '%>'), 
  'tag_block' => array('<%', '%>'), 
  'tag_variable' => array('<%=', '%>'),
));
```

```php
// SGML Comment Syntax
$lexer = new Twig_Lexer($twig, array( 
  'tag_comment' => array('<!--#', '-->'), 
  'tag_block' => array('<!--', '-->'), 
  'tag_variable' => array('${', '}'),
  ));
```

```twig
 // Smarty like
$lexer = new Twig_Lexer($twig, array( 
  'tag_comment' => array('{*', '*}'), 
  'tag_block' => array('{', '}'), 
  'tag_variable' => array('{$', '}'),
));
```

###### Используя динамические свойства объектов

Когда Twig находит переменную вроде этой ```article.title```, то он пытается найти публичное свойство ```title``` в объекте ```article```.

Такой подход будет работать даже если свойство объявляется динамически, спасибо методу ```__get()``` за это; второй метод, который необходимо реализовать - ```__isset()```:

```php
class Article
{
  public function __get($name)
  {
    if ('title' === $name) {
      return 'This title';
    }
    
    // выбросить исключение
  }
  
  public function __isset($name)
  {
    if ('title' === $name) {
      return true;
    }
    
    return false;
  }
}
```

###### Получаем доступ к родительскому контексту вложенного цикла

Иногда бывает необходимо получить доступ к родительскому контексту вложенного цикла, для этого есть переменная ```loop.parent```. Например, если есть следующая структура данных:

```php
$data = array(
  'topics' => array(
    'topic1' => array('Message 1 Topic 1', 'Message 2 Topic 1'),
    'topic2' => array('Message 1 Topic 2', 'Message 2 Topic 2')
  )
);
```

И следующий код для отображения всех сообщений записи:

```twig
{% for topic, messages in topics %}
  * {{ loop.index }}: {{ topic }}
  {% for messages in messages %}
    - {{ loop.parent.loop.index }}.{{ loop.index }}: {{ message }}
  {% endfor %}
{% endfor %}
```

Вывод будет следующим:

```
 * 1: topic1
  - 1.1: The message 1 of topic 1
  - 1.2: The message 2 of topic 1
* 2: topic2
  - 2.1: The message 1 of topic 2
  - 2.2: The message 2 of topic 2
```

Во вложенном цикле переменная ```loop.parent``` предназначена для получения внешнего контекста. Порядковый индекс текущей темы доступен через переменную ```loop.parent.loop.index```.

###### Объявляем необъявленные функции и фильтры на лету

При попытке вызова несуществующей функции или фильтра Twig, по-умолчанию, выбрасывает исключение ```Twig_Error_Syntax```. Однако Twig может вызвать коллбек-функцию, которая вернёт либо фильтр, либо другую функцию.

Для фильтров регистрация коллбек-функций происходит через метод ```registerUndefinedFilterCallback()```, для функций - через метод ```registerUndefinedFunctionCallback()```:

```php
// автоматически регистрирует все функции PHP в Twig
// не рекомендуем такого делать!

$twig->registerUndefinedFunctionCallback(function($name) {
  if (function_exists($name)) {
    return new Twig_Function($name, $name);
  }
  
  return false;
})
```

Если коллбек-функция не может вернуть действительную функцию или фильтр, то она должна вернуть значение ```false```. Если были зарегистрированы несколько коллбек-функций, то каждая из них будет вызвана до тех пор, пока не будет возвращено значение ```false```. Так как определение фильтров и функций происходит на этапе компиляции, то добавление коллбек-функций не приводит к каким-либо негативным последствиям в плане эффективности работы Twig.

###### Проверка корректности синтаксиса шаблона

Когда исходный код шаблона предоставляется третьей стороной, например, через веб-интерфейс, то бывает крайне полезно перед сохранением такого шаблона провести его проверку на корректность. Допустим, что исходный код шаблона хранится в переменной ```$template```, вот каким образом будет выглядеть возможная проверка шаблона:

```php
try {
  $twig->parse($twig->tokenize(new Twig_Source($template)));
  
  // шаблон корректен
} catch (Twig_Error_Syntax $e) {
  // шаблон содержит одну или более ошибок
}
```

Если вы перебираете шаблоны в цикле, то метод ```tokenize()``` может принимать имя файла, в таком случае будет возможность вместе с ошибкой вывести и название недействительного шаблона:

```php
foreach($files as $file) {
  try {
    $twig->parse($twig->tokenize(new Twig_Source($template, $file->getFilename(), $file)));
    
    // шаблон корректен
  } catch (Twig_Error_Syntax $e) {
    // шаблон содержит одну или более ошибок
  }
}
```

Такой подход не защитит от получения доступа к запрещенным методам или полям объектов, т.к. политика безопасности проверяется на уровне вывода результатов работы шаблонизатора.
